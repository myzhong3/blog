{"meta":{"title":"曙光之路","subtitle":"","description":"","author":"Alex Zhong","url":"http://myzhong3.github.io","root":"/"},"pages":[],"posts":[{"title":"java泛型中的通配符","slug":"java泛型中的通配符","date":"2021-01-09T13:25:33.000Z","updated":"2021-01-16T09:20:07.232Z","comments":true,"path":"2021/01/09/java泛型中的通配符/","link":"","permalink":"http://myzhong3.github.io/2021/01/09/java%E6%B3%9B%E5%9E%8B%E4%B8%AD%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6/","excerpt":"","text":"From java doc: https://docs.oracle.com/javase/tutorial/extra/generics/morefun.html In general, if you have an API that only uses a type parameter T as an argument, its uses should take advantage of lower bounded wildcards (? super T). Conversely, if the API only returns T, you’ll give your clients more flexibility by using upper bounded wildcards (? extends T). 使用规则（编译时的限制） 比如：List&lt;? Super T&gt; List&lt;? extends T&gt; 则：写（前者）和读（后者）时使用的对象必须是T的派生类或者T本身。 这两个通配符写法存在的原因是为了提供使用泛型的Collection的宽容性。比如T是S的派生类，但是Collection&lt;T&gt;并不是Collectio&lt;S&gt;的派生类，所以function(Collection&lt;S&gt;)并不允许传入Collection&lt;T&gt;类型的对象。相对应的，function(Collection&lt;? extends S&gt;)就允许传入Collection&lt;T&gt;类型的对象。","categories":[],"tags":[{"name":"java generics 泛型 wildcard 通配符","slug":"java-generics-泛型-wildcard-通配符","permalink":"http://myzhong3.github.io/tags/java-generics-%E6%B3%9B%E5%9E%8B-wildcard-%E9%80%9A%E9%85%8D%E7%AC%A6/"}]},{"title":"ZT-java接口里面可以有成员变量么？","slug":"java接口里面可以有成员变量么？","date":"2021-01-03T09:32:32.000Z","updated":"2021-01-03T09:33:12.184Z","comments":true,"path":"2021/01/03/java接口里面可以有成员变量么？/","link":"","permalink":"http://myzhong3.github.io/2021/01/03/java%E6%8E%A5%E5%8F%A3%E9%87%8C%E9%9D%A2%E5%8F%AF%E4%BB%A5%E6%9C%89%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B9%88%EF%BC%9F/","excerpt":"","text":"转帖 答案是：可以，但必须是public static final的，而且必须是public static final的。 既然JDK1.7开始支持接口中存在default方法和static方法，那么这些方法在实现上，难免需要成员变量提供数据支持。先看一个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//基于JDK1.8//IA.javapublic interface IA &#123; int a = 100; double NUM = 1;//等价于public static final double NUM = 1; String name = &quot;IA&quot;; void say(); default void print() &#123; System.out.println(&quot;IA:print()&quot;); &#125; default void pritA() &#123; System.out.println(&quot;IA: &quot; + name); &#125;&#125;//IB.javapublic interface IB &#123; int b = 200; double NUM = 2; String name = &quot;IB&quot;; void say(); default void print() &#123; System.out.println(&quot;IB:print()&quot;); &#125; default void pritB() &#123; System.out.println(&quot;IB: &quot; + name); &#125;&#125;//AB.javapublic class AB implements IA, IB &#123; public static void main(String[] args) &#123; AB ab = new AB(); //ab.name 报错，不能确定是IA中的name还是IB中的 System.out.println(a);//100 因为a和b本质上是静态成员，在静态方法里面可以直接访问 System.out.println(b);//200 System.out.println(IA.NUM);//1.0 System.out.println(IB.NUM);//2.0 System.out.println(IA.name);//IA System.out.println(IB.name);//IB ab.say();//AB:say() ab.print();//AB:print() ab.pritA();//IA: IA ab.pritB();//IB: IB &#125; //必须实现接口中未实现的方法，并且根据排序规则，实现的是IA中的say() @Override public void say() &#123; System.out.println(&quot;AB:say()&quot;); &#125; //必须重写IA和IB中重复(签名相同)的default方法，否则调用print时不知道调用IA中的实现，还是IB中的。 @Override public void print() &#123; System.out.println(&quot;AB:print()&quot;); &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 据此得出结论： 接口中的成员变量默认且只能是public static final的，加这几个访问修饰符是多余的。 接口中的成员变量在实现类中可以直接访问（不管是静态方法还是非静态方法），如果父接口中有重复出现的成员变量，则只能带上接口名加以区分。 接口中default修饰的方法，为子类提供默认实现。 子类实现多个接口，多个接口中有同样签名的方法时，根据排序规则，以写在前面的接口为准。如果父接口中的default方法有重复，则子类必须重写此方法（不然，多个接口中分别提供了各自的实现，子类会不知道调用哪一个）。","categories":[],"tags":[{"name":"java interface member","slug":"java-interface-member","permalink":"http://myzhong3.github.io/tags/java-interface-member/"}]},{"title":"default method in java interface","slug":"default-method-in-java-interface","date":"2021-01-03T09:25:53.000Z","updated":"2021-01-03T09:26:41.227Z","comments":true,"path":"2021/01/03/default-method-in-java-interface/","link":"","permalink":"http://myzhong3.github.io/2021/01/03/default-method-in-java-interface/","excerpt":"","text":"在Java中可以为接口定义一个默认方法的实现，使用的关键字就是default，有了默认方法，实现类就可以不对接口中的默认方法进行重写。 1234567891011121314151617181920212223//为person接口定义两个默认的实现方法public interface Person &#123; default void print()&#123; System.out.println(&quot;i am person&quot;); &#125; default void eat()&#123; System.out.println(&quot;eat&quot;); &#125;&#125;//张三类去实现Person接口中的print()方法public class Zhangsan implements Person&#123; @Override public void print() &#123; System.out.println(&quot;i am zhangsan&quot;); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; var person = new Zhangsan(); person.print(); person.eat(); &#125;&#125; 运行结果： 12i am zhangsaneat","categories":[],"tags":[{"name":"java default interface","slug":"java-default-interface","permalink":"http://myzhong3.github.io/tags/java-default-interface/"}]},{"title":"ZT-Hexo+Github Page","slug":"ZT-Hexo-Github-Page","date":"2020-12-20T03:54:19.000Z","updated":"2020-12-20T04:20:45.591Z","comments":true,"path":"2020/12/20/ZT-Hexo-Github-Page/","link":"","permalink":"http://myzhong3.github.io/2020/12/20/ZT-Hexo-Github-Page/","excerpt":"","text":"超详细Hexo+Github Page搭建技术博客教程【持续更新】https://segmentfault.com/a/1190000017986794","categories":[],"tags":[{"name":"hexo, GitHub, zt","slug":"hexo-GitHub-zt","permalink":"http://myzhong3.github.io/tags/hexo-GitHub-zt/"}]},{"title":"How to use hexo","slug":"How-to-use-hexo","date":"2020-12-06T06:42:35.000Z","updated":"2020-12-06T07:13:51.201Z","comments":true,"path":"2020/12/06/How-to-use-hexo/","link":"","permalink":"http://myzhong3.github.io/2020/12/06/How-to-use-hexo/","excerpt":"","text":"create post hexo new &#39;title&#39; generate hexo hexo g deploy locally hexo s Clean cache hexo clean generate and deploy remote hexo g -d create draft and publish draft hexo new draft &#39;title&#39; hexo publish &#39;title&#39;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-12-06T03:23:00.830Z","updated":"2020-12-06T03:23:00.830Z","comments":true,"path":"2020/12/06/hello-world/","link":"","permalink":"http://myzhong3.github.io/2020/12/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"java generics 泛型 wildcard 通配符","slug":"java-generics-泛型-wildcard-通配符","permalink":"http://myzhong3.github.io/tags/java-generics-%E6%B3%9B%E5%9E%8B-wildcard-%E9%80%9A%E9%85%8D%E7%AC%A6/"},{"name":"java interface member","slug":"java-interface-member","permalink":"http://myzhong3.github.io/tags/java-interface-member/"},{"name":"java default interface","slug":"java-default-interface","permalink":"http://myzhong3.github.io/tags/java-default-interface/"},{"name":"hexo, GitHub, zt","slug":"hexo-GitHub-zt","permalink":"http://myzhong3.github.io/tags/hexo-GitHub-zt/"}]}