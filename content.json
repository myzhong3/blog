{"meta":{"title":"曙光之路","subtitle":"","description":"","author":"Alex Zhong","url":"http://myzhong3.github.io","root":"/"},"pages":[],"posts":[{"title":"Java 11新特性","slug":"Java-11新特性","date":"2021-06-05T07:05:02.000Z","updated":"2021-06-05T07:06:26.402Z","comments":true,"path":"2021/06/05/Java-11新特性/","link":"","permalink":"http://myzhong3.github.io/2021/06/05/Java-11%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"","text":"Java 11 新特性介绍转载：原文地址 Java 11 已于 2018 年 9 月 25 日正式发布，之前在 Java 10 新特性介绍中介绍过，为了加快的版本迭代、跟进社区反馈，Java 的版本发布周期调整为每六个月一次——即每半年发布一个大版本，每个季度发布一个中间特性版本，并且做出不会跳票的承诺。通过这样的方式，Java 开发团队能够将一些重要特性尽早的合并到 Java Release 版本中，以便快速得到开发者的反馈，避免出现类似 Java 9 发布时的两次延期的情况。 按照官方介绍，新的版本发布周期将会严格按照时间节点，于每年的 3 月和 9 月发布，Java 11 发布的时间节点也正好处于 Java 8 免费更新到期的前夕。与 Java 9 和 Java 10 这两个被称为”功能性的版本”不同，Java 11 仅将提供长期支持服务（LTS, Long-Term-Support），还将作为 Java 平台的默认支持版本，并且会提供技术支持直至 2023 年 9 月，对应的补丁和安全警告等支持将持续至 2026 年。 本文主要针对 Java 11 中的新特性展开介绍，让您快速了解 Java 11 带来的变化。 基于嵌套的访问控制与 Java 语言中现有的嵌套类型概念一致, 嵌套访问控制是一种控制上下文访问的策略，允许逻辑上属于同一代码实体，但被编译之后分为多个分散的 class 文件的类，无需编译器额外的创建可扩展的桥接访问方法，即可访问彼此的私有成员，并且这种改进是在 Java 字节码级别的。 在 Java 11 之前的版本中，编译之后的 class 文件中通过 InnerClasses 和 Enclosing Method 两种属性来帮助编译器确认源码的嵌套关系，每一个嵌套的类会编译到自己所在的 class 文件中，不同类的文件通过上面介绍的两种属性的来相互连接。这两种属性对于编译器确定相互之间的嵌套关系已经足够了，但是并不适用于访问控制。这里大家可以写一段包含内部类的代码，并将其编译成 class 文件，然后通过 javap 命令行来分析，碍于篇幅，这里就不展开讨论了。 Java 11 中引入了两个新的属性：一个叫做 NestMembers 的属性，用于标识其它已知的静态 nest 成员；另外一个是每个 nest 成员都包含的 NestHost 属性，用于标识出它的 nest 宿主类。 标准 HTTP Client 升级Java 11 对 Java 9 中引入并在 Java 10 中进行了更新的 Http Client API 进行了标准化，在前两个版本中进行孵化的同时，Http Client 几乎被完全重写，并且现在完全支持异步非阻塞。 新版 Java 中，Http Client 的包名由 jdk.incubator.http 改为 java.net.http，该 API 通过 CompleteableFutures 提供非阻塞请求和响应语义，可以联合使用以触发相应的动作，并且 RX Flo**w 的概念也在 Java 11 中得到了实现。现在，在用户层请求发布者和响应发布者与底层套接字之间追踪数据流更容易了。这降低了复杂性，并最大程度上提高了 HTTP / 1 和 HTTP / 2 之间的重用的可能性。 Java 11 中的新 Http Client API，提供了对 HTTP/2 等业界前沿标准的支持，同时也向下兼容 HTTP/1.1，精简而又友好的 API 接口，与主流开源 API（如：Apache HttpClient、Jetty、OkHttp 等）类似甚至拥有更高的性能。与此同时它是 Java 在 Reactive-Stream 方面的第一个生产实践，其中广泛使用了 Java Flow API，终于让 Java 标准 HTTP 类库在扩展能力等方面，满足了现代互联网的需求，是一个难得的现代 Http/2 Client API 标准的实现，Java 工程师终于可以摆脱老旧的 HttpURLConnection 了。下面模拟 Http GET 请求并打印返回内容： 1234567891011121314151617181920212223242526272829HttpClient client = HttpClient.newHttpClient();HttpRequest request = HttpRequest.newBuilder() .uri(URI.create(&quot;http://openjdk.java.net/&quot;)) .build();client.sendAsync(request, BodyHandlers.ofString()) .thenApply(HttpResponse::body) .thenAccept(System.out::println) .join(); Epsilon：低开销垃圾回收器Epsilon 垃圾回收器的目标是开发一个控制内存分配，但是不执行任何实际的垃圾回收工作。它提供一个完全消极的 GC 实现，分配有限的内存资源，最大限度的降低内存占用和内存吞吐延迟时间。 Java 版本中已经包含了一系列的高度可配置化的 GC 实现。各种不同的垃圾回收器可以面对各种情况。但是有些时候使用一种独特的实现，而不是将其堆积在其他 GC 实现上将会是事情变得更加简单。 下面是 no-op GC 的几个使用场景： 性能测试：什么都不执行的 GC 非常适合用于 GC 的差异性分析。no-op （无操作）GC 可以用于过滤掉 GC 诱发的性能损耗，比如 GC 线程的调度，GC 屏障的消耗，GC 周期的不合适触发，内存位置变化等。此外有些延迟者不是由于 GC 引起的，比如 scheduling hiccups, compiler transition hiccups，所以去除 GC 引发的延迟有助于统计这些延迟。 内存压力测试：在测试 Java 代码时，确定分配内存的阈值有助于设置内存压力常量值。这时 no-op 就很有用，它可以简单地接受一个分配的内存分配上限，当内存超限时就失败。例如：测试需要分配小于 1G 的内存，就使用-Xmx1g 参数来配置 no-op GC，然后当内存耗尽的时候就直接 crash。 VM 接口测试：以 VM 开发视角，有一个简单的 GC 实现，有助于理解 VM-GC 的最小接口实现。它也用于证明 VM-GC 接口的健全性。 极度短暂 job 任务：一个短声明周期的 job 任务可能会依赖快速退出来释放资源，这个时候接收 GC 周期来清理 heap 其实是在浪费时间，因为 heap 会在退出时清理。并且 GC 周期可能会占用一会时间，因为它依赖 heap 上的数据量。 延迟改进：对那些极端延迟敏感的应用，开发者十分清楚内存占用，或者是几乎没有垃圾回收的应用，此时耗时较长的 GC 周期将会是一件坏事。 吞吐改进：即便对那些无需内存分配的工作，选择一个 GC 意味着选择了一系列的 GC 屏障，所有的 OpenJDK GC 都是分代的，所以他们至少会有一个写屏障。避免这些屏障可以带来一点点的吞吐量提升。 Epsilon 垃圾回收器和其他 OpenJDK 的垃圾回收器一样，可以通过参数 -XX:+UseEpsilonGC 开启。 Epsilon 线性分配单个连续内存块。可复用现存 VM 代码中的 TLAB 部分的分配功能。非 TLAB 分配也是同一段代码，因为在此方案中，分配 TLAB 和分配大对象只有一点点的不同。Epsilon 用到的 barrier 是空的(或者说是无操作的)。因为该 GC 执行任何的 GC 周期，不用关系对象图，对象标记，对象复制等。引进一种新的 barrier-set 实现可能是该 GC 对 JVM 最大的变化。 简化启动单个源代码文件的方法Java 11 版本中最令人兴奋的功能之一是增强 Java 启动器，使之能够运行单一文件的 Java 源代码。此功能允许使用 Java 解释器直接执行 Java 源代码。源代码在内存中编译，然后由解释器执行。唯一的约束在于所有相关的类必须定义在同一个 Java 文件中。 此功能对于开始学习 Java 并希望尝试简单程序的人特别有用，并且能与 jshell 一起使用，将成为任何初学者学习语言的一个很好的工具集。不仅初学者会受益，专业人员还可以利用这些工具来探索新的语言更改或尝试未知的 API。 如今单文件程序在编写小实用程序时很常见，特别是脚本语言领域。从中开发者可以省去用 Java 编译程序等不必要工作，以及减少新手的入门障碍。在基于 Java 10 的程序实现中可以通过三种方式启动： 作为 * .class 文件 作为 * .jar 文件中的主类 作为模块中的主类 而在最新的 Java 11 中新增了一个启动方式，即可以在源代码中声明类，例如：如果名为 HelloWorld.java 的文件包含一个名为 hello.World 的类，那么该命令： 1$ java HelloWorld.java 也等同于： 123456789$ javac HelloWorld.java $ java -cp . hello.World 用于 Lambda 参数的局部变量语法在 Lambda 表达式中使用局部变量类型推断是 Java 11 引入的唯一与语言相关的特性，这一节，我们将探索这一新特性。 从 Java 10 开始，便引入了局部变量类型推断这一关键特性。类型推断允许使用关键字 var 作为局部变量的类型而不是实际类型，编译器根据分配给变量的值推断出类型。这一改进简化了代码编写、节省了开发者的工作时间，因为不再需要显式声明局部变量的类型，而是可以使用关键字 var，且不会使源代码过于复杂。 可以使用关键字 var 声明局部变量，如下所示： 12345var s = &quot;Hello Java 11&quot;;System.out.println(s); 但是在 Java 10 中，还有下面几个限制： 只能用于局部变量上 声明时必须初始化 不能用作方法参数 不能在 Lambda 表达式中使用 Java 11 与 Java 10 的不同之处在于允许开发者在 Lambda 表达式中使用 var 进行参数声明。乍一看，这一举措似乎有点多余，因为在写代码过程中可以省略 Lambda 参数的类型，并通过类型推断确定它们。但是，添加上类型定义同时使用 @Nonnull 和 @Nullable 等类型注释还是很有用的，既能保持与局部变量的一致写法，也不丢失代码简洁。 Lambda 表达式使用隐式类型定义，它形参的所有类型全部靠推断出来的。隐式类型 Lambda 表达式如下： 1(x, y) -&gt; x.process(y) Java 10 为局部变量提供隐式定义写法如下： 123456789var x = new Foo();for (var x : xs) &#123; ... &#125;try (var x = ...) &#123; ... &#125; catch ... 为了 Lambda 类型表达式中正式参数定义的语法与局部变量定义语法的不一致，且为了保持与其他局部变量用法上的一致性，希望能够使用关键字 var 隐式定义 Lambda 表达式的形参： 1(var x, var y) -&gt; x.process(y) 于是在 Java 11 中将局部变量和 Lambda 表达式的用法进行了统一，并且可以将注释应用于局部变量和 Lambda 表达式： 12345@Nonnull var x = new Foo();(@Nonnull var x, @Nullable var y) -&gt; x.process(y) 低开销的 Heap ProfilingJava 11 中提供一种低开销的 Java 堆分配采样方法，能够得到堆分配的 Java 对象信息，并且能够通过 JVMTI 访问堆信息。 引入这个低开销内存分析工具是为了达到如下目的： 足够低的开销，可以默认且一直开启 能通过定义好的程序接口访问 能够对所有堆分配区域进行采样 能给出正在和未被使用的 Java 对象信息 对用户来说，了解它们堆里的内存分布是非常重要的，特别是遇到生产环境中出现的高 CPU、高内存占用率的情况。目前有一些已经开源的工具，允许用户分析应用程序中的堆使用情况，比如：Java Flight Recorder、jmap、YourKit 以及 VisualVM tools.。但是这些工具都有一个明显的不足之处：无法得到对象的分配位置，headp dump 以及 heap histogram 中都没有包含对象分配的具体信息，但是这些信息对于调试内存问题至关重要，因为它能够告诉开发人员他们的代码中发生的高内存分配的确切位置，并根据实际源码来分析具体问题，这也是 Java 11 中引入这种低开销堆分配采样方法的原因。 支持 TLS 1.3 协议Java 11 中包含了传输层安全性（TLS）1.3 规范（RFC 8446）的实现，替换了之前版本中包含的 TLS，包括 TLS 1.2，同时还改进了其他 TLS 功能，例如 OCSP 装订扩展（RFC 6066，RFC 6961），以及会话散列和扩展主密钥扩展（RFC 7627），在安全性和性能方面也做了很多提升。 新版本中包含了 Java 安全套接字扩展（JSSE）提供 SSL，TLS 和 DTLS 协议的框架和 Java 实现。目前，JSSE API 和 JDK 实现支持 SSL 3.0，TLS 1.0，TLS 1.1，TLS 1.2，DTLS 1.0 和 DTLS 1.2。 同时 Java 11 版本中实现的 TLS 1.3，重新定义了以下新标准算法名称： TLS 协议版本名称：TLSv1.3 SSLContext 算法名称：TLSv1.3 TLS 1.3 的 TLS 密码套件名称：TLS_AES_128_GCM_SHA256，TLS_AES_256_GCM_SHA384 用于 X509KeyManager 的 keyType：RSASSA-PSS 用于 X509TrustManager 的 authType：RSASSA-PSS 还为 TLS 1.3 添加了一个新的安全属性 jdk.tls.keyLimits。当处理了特定算法的指定数据量时，触发握手后，密钥和 IV 更新以导出新密钥。还添加了一个新的系统属性 jdk.tls.server.protocols，用于在 SunJSSE 提供程序的服务器端配置默认启用的协议套件。 之前版本中使用的 KRB5密码套件实现已从 Java 11 中删除，因为该算法已不再安全。同时注意，TLS 1.3 与以前的版本不直接兼容。 升级到 TLS 1.3 之前，需要考虑如下几个兼容性问题： TLS 1.3 使用半关闭策略，而 TLS 1.2 以及之前版本使用双工关闭策略，对于依赖于双工关闭策略的应用程序，升级到 TLS 1.3 时可能存在兼容性问题。 TLS 1.3 使用预定义的签名算法进行证书身份验证，但实际场景中应用程序可能会使用不被支持的签名算法。 TLS 1.3 再支持 DSA 签名算法，如果在服务器端配置为仅使用 DSA 证书，则无法升级到 TLS 1.3。 TLS 1.3 支持的加密套件与 TLS 1.2 和早期版本不同，若应用程序硬编码了加密算法单元，则在升级的过程中需要修改相应代码才能升级使用 TLS 1.3。 TLS 1.3 版本的 session 用行为及秘钥更新行为与 1.2 及之前的版本不同，若应用依赖于 TLS 协议的握手过程细节，则需要注意。 ZGC：可伸缩低延迟垃圾收集器ZGC 即 Z Garbage Collector（垃圾收集器或垃圾回收器），这应该是 Java 11 中最为瞩目的特性，没有之一。ZGC 是一个可伸缩的、低延迟的垃圾收集器，主要为了满足如下目标进行设计： GC 停顿时间不超过 10ms 即能处理几百 MB 的小堆，也能处理几个 TB 的大堆 应用吞吐能力不会下降超过 15%（与 G1 回收算法相比） 方便在此基础上引入新的 GC 特性和利用 colord 针以及 Load barriers 优化奠定基础 当前只支持 Linux/x64 位平台 停顿时间在 10ms 以下，10ms 其实是一个很保守的数据，即便是 10ms 这个数据，也是 GC 调优几乎达不到的极值。根据 SPECjbb 2015 的基准测试，128G 的大堆下最大停顿时间才 1.68ms，远低于 10ms，和 G1 算法相比，改进非常明显。 图 1. 回收算法停顿时间对比 不过目前 ZGC 还处于实验阶段，目前只在 Linux/x64 上可用，如果有足够的需求，将来可能会增加对其他平台的支持。同时作为实验性功能的 ZGC 将不会出现在 JDK 构建中，除非在编译时使用 configure 参数：--with-jvm-features=zgc 显式启用。 在实验阶段，编译完成之后，已经迫不及待的想试试 ZGC，需要配置以下 JVM 参数，才能使用 ZGC，具体启动 ZGC 参数如下： 1-XX：+ UnlockExperimentalVMOptions -XX：+ UseZGC -Xmx10g 其中参数：-Xmx 是 ZGC 收集器中最重要的调优选项，大大解决了程序员在 JVM 参数调优上的困扰。ZGC 是一个并发收集器，必须要设置一个最大堆的大小，应用需要多大的堆，主要有下面几个考量： 对象的分配速率，要保证在 GC 的时候，堆中有足够的内存分配新对象。 一般来说，给 ZGC 的内存越多越好，但是也不能浪费内存，所以要找到一个平衡。 飞行记录器飞行记录器之前是商业版 JDK 的一项分析工具，但在 Java 11 中，其代码被包含到公开代码库中，这样所有人都能使用该功能了。 Java 语言中的飞行记录器类似飞机上的黑盒子，是一种低开销的事件信息收集框架，主要用于对应用程序和 JVM 进行故障检查、分析。飞行记录器记录的主要数据源于应用程序、JVM 和 OS，这些事件信息保存在单独的事件记录文件中，故障发生后，能够从事件记录文件中提取出有用信息对故障进行分析。 启用飞行记录器参数如下： 1-XX:StartFlightRecording 也可以使用 bin/jcmd 工具启动和配置飞行记录器： 清单 2. 飞行记录器启动、配置参数示例 123456789$ jcmd &lt;pid&gt; JFR.start$ jcmd &lt;pid&gt; JFR.dump filename&#x3D;recording.jfr$ jcmd &lt;pid&gt; JFR.stop JFR 使用测试： 清单 3. JFR 使用示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class FlightRecorderTest extends Event &#123; @Label(&quot;Hello World&quot;) @Description(&quot;Helps the programmer getting started&quot;) static class HelloWorld extends Event &#123; @Label(&quot;Message&quot;) String message; &#125; public static void main(String[] args) &#123; HelloWorld event = new HelloWorld(); event.message = &quot;hello, world!&quot;; event.commit(); &#125;&#125; 在运行时加上如下参数： 1java -XX:StartFlightRecording&#x3D;duration&#x3D;1s, filename&#x3D;recording.jfr 下面读取上一步中生成的 JFR 文件：recording.jfr 清单 4. 飞行记录器分析示例 12345678910111213141516171819202122232425public void readRecordFile() throws IOException &#123; final Path path = Paths.get(&quot;D:\\\\ java \\\\recording.jfr&quot;); final List&lt;RecordedEvent&gt; recordedEvents = RecordingFile.readAllEvents(path); for (RecordedEvent event : recordedEvents) &#123; System.out.println(event.getStartTime() + &quot;,&quot; + event.getValue(&quot;message&quot;)); &#125;&#125; 动态类文件常量为了使 JVM 对动态语言更具吸引力，Java 的第七个版本已将 invokedynamic 引入其指令集。 过 Java 开发人员通常不会注意到此功能，因为它隐藏在 Java 字节代码中。通过使用 invokedynamic，可以延迟方法调用的绑定，直到第一次调用。例如，Java 语言使用该技术来实现 Lambda 表达式，这些表达式仅在首次使用时才显示出来。这样做，invokedynamic 已经演变成一种必不可少的语言功能。 Java 11 引入了类似的机制，扩展了 Java 文件格式，以支持新的常量池：CONSTANT_Dynamic，它在初始化的时候，像 invokedynamic 令生成代理方法一样，委托给 bootstrap 方法进行初始化创建，对上层软件没有很大的影响，降低开发新形式的可实现类文件约束带来的成本和干扰。 结束语Java 在更新发布周期为每半年发布一次之后，在合并关键特性、快速得到开发者反馈等方面，做得越来越好。Java 11 版本的发布也带来了不少新特性和功能增强、性能提升、基础能力的全面进步和突破，本文针对其中对使用人员影响重大的以及主要的特性做了介绍。Java 12 即将到来，您准备好了吗？ 本文仅代表作者个人观点，不代表其所在单位的意见，如有不足之处，还望您能够海涵。希望您能够反馈意见，交流心得，一同进步。 参考资源 参考 JDK 11，查看更多有关 Java 10 的最新信息。 参考 The Z Garbage Collector - An Introduction，查看更多有关 ZGC 的最新信息。 Java 10 新特性介绍 轻松迁移至 Java 11 Java 12 新特性概述","categories":[],"tags":[{"name":"Java java11","slug":"Java-java11","permalink":"http://myzhong3.github.io/tags/Java-java11/"}]},{"title":"从JAVA5到JAVA10新特性总结","slug":"从JAVA5到JAVA10新特性总结","date":"2021-01-23T07:11:05.000Z","updated":"2021-03-06T05:55:24.417Z","comments":true,"path":"2021/01/23/从JAVA5到JAVA10新特性总结/","link":"","permalink":"http://myzhong3.github.io/2021/01/23/%E4%BB%8EJAVA5%E5%88%B0JAVA10%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/","excerpt":"","text":"转贴自： [https://blog.csdn.net/visant/article/details/79778967]: 要了解一门语言，最好的方式就是要能从基础的版本进行了解，升级的过程，以及升级的新特性，这样才能循序渐进的学好一门语言。 JDK5新特性1：自动装箱与拆箱：自动装箱的过程：每当需要一种类型的对象时，这种基本类型就自动地封装到与它相同类型的包装类中。 自动拆箱的过程：每当需要一个值时，被包装对象中的值就被自动地提取出来，没必要再去调用intValue()和doubleValue()方法。 自动装箱，只需将该值赋给一个类型包装器引用，java会自动创建一个对象。 自动拆箱，只需将该对象值赋给一个基本类型即可。 java——类的包装器 类型包装器有：Double,Float,Long,Integer,Short,Character和Boolean 2：枚举 把集合里的对象元素一个一个提取出来。枚举类型使代码更具可读性，理解清晰，易于维护。枚举类型是强类型的，从而保证了系统安全性。而以类的静态字段实现的类似替代模型，不具有枚举的简单性和类型安全性。 简单的用法：JavaEnum简单的用法一般用于代表一组常用常量，可用来代表一类相同类型的常量值。 复杂用法：Java为枚举类型提供了一些内置的方法，同事枚举常量还可以有自己的方法。可以很方便的遍历枚举对象。 3：静态导入 通过使用 import static，就可以不用指定 Constants 类名而直接使用静态成员，包括静态方法。 import xxxx 和 import static xxxx的区别是前者一般导入的是类文件如import java.util.Scanner；后者一般是导入静态的方法，import static java.lang.System.out。 4：可变参数（Varargs） 可变参数的简单语法格式为： methodName([argumentList], dataType… argumentName); 5：内省（Introspector） 内省是Java语言对Bean类属性、事件的一种缺省处理方法。例如类A中有属性name,那我们可以通过getName,setName来得到其值或者设置新的值。通过getName/setName来访问name属性，这就是默认的规则。Java中提供了一套API用来访问某个属性的getter /setter方法，通过这些API可以使你不需要了解这个规则（但你最好还是要搞清楚），这些API存放于包java.beans中。 一 般的做法是通过类Introspector来获取某个对象的BeanInfo信息，然后通过BeanInfo来获取属性的描述器 （PropertyDescriptor），通过这个属性描述器就可以获取某个属性对应的getter/setter方法，然后我们就可以通过反射机制来调用这些方法。 6：泛型(Generic) C++ 通过模板技术可以指定集合的元素类型，而Java在1.5之前一直没有相对应的功能。一个集合可以放任何类型的对象，相应地从集合里面拿对象的时候我们也不得不对他们进行强制得类型转换。引入了泛型，它允许指定集合里元素的类型，这样你可以得到强类型在编译时刻进行类型检查的好处。 7：For-Each循环 For-Each循环得加入简化了集合的遍历。假设我们要遍历一个集合对其中的元素进行一些处理。 JDK 6新特性1：Desktop类和SystemTray类 在JDK6中 ,AWT新增加了两个类:Desktop和SystemTray。 前者可以用来打开系统默认浏览器浏览指定的URL,打开系统默认邮件客户端给指定的邮箱发邮件,用默认应用程序打开或编辑文件(比如,用记事本打开以txt为后缀名的文件),用系统默认的打印机打印文档;后者可以用来在系统托盘区创建一个托盘程序. 2：使用JAXB2来实现对象与XML之间的映射 JAXB是Java Architecture for XML Binding的缩写，可以将一个Java对象转变成为XML格式，反之亦然。 我们把对象与关系数据库之间的映射称为ORM, 其实也可以把对象与XML之间的映射称为OXM(Object XML Mapping). 原来JAXB是Java EE的一部分，在JDK6中，SUN将其放到了Java SE中，这也是SUN的一贯做法。JDK6中自带的这个JAXB版本是2.0, 比起1.0(JSR 31)来，JAXB2(JSR 222)用JDK5的新特性Annotation来标识要作绑定的类和属性等，这就极大简化了开发的工作量。 实 际上，在Java EE 5.0中，EJB和Web Services也通过Annotation来简化开发工作。另外,JAXB2在底层是用StAX(JSR 173)来处理XML文档。除了JAXB之外，我们还可以通过XMLBeans和Castor等来实现同样的功能。 3：理解StAX StAX(JSR 173)是JDK6.0中除了DOM和SAX之外的又一种处理XML文档的API。 StAX 的来历 ：在JAXP1.3(JSR 206)有两种处理XML文档的方法:DOM(Document Object Model)和SAX(Simple API for XML). 由 于JDK6.0中的JAXB2(JSR 222)和JAX-WS 2.0(JSR 224)都会用到StAX，所以Sun决定把StAX加入到JAXP家族当中来，并将JAXP的版本升级到1.4(JAXP1.4是JAXP1.3的维护版本). JDK6里面JAXP的版本就是1.4. 。 StAX是The Streaming API for XML的缩写，一种利用拉模式解析(pull-parsing)XML文档的API.StAX通过提供一种基于事件迭代器(Iterator)的API让程序员去控制xml文档解析过程,程序遍历这个事件迭代器去处理每一个解析事件，解析事件可以看做是程序拉出来的，也就是程序促使解析器产生一个解析事件，然后处理该事件，之后又促使解析器产生下一个解析事件，如此循环直到碰到文档结束符； SAX也是基于事件处理xml文档，但却是用推模式解析，解析器解析完整个xml文档后，才产生解析事件，然后推给程序去处理这些事件；DOM 采用的方式是将整个xml文档映射到一颗内存树，这样就可以很容易地得到父节点和子结点以及兄弟节点的数据，但如果文档很大，将会严重影响性能。 4.使用Compiler API 现在我们可以用JDK6 的Compiler API(JSR 199)去动态编译Java源文件，Compiler API结合反射功能就可以实现动态的产生Java代码并编译执行这些代码，有点动态语言的特征。 这个特性对于某些需要用到动态编译的应用程序相当有用，比如JSP Web Server，当我们手动修改JSP后，是不希望需要重启Web Server才可以看到效果的，这时候我们就可以用Compiler API来实现动态编译JSP文件，当然，现在的JSP Web Server也是支持JSP热部署的，现在的JSP Web Server通过在运行期间通过Runtime.exec或ProcessBuilder来调用javac来编译代码，这种方式需要我们产生另一个进程去做编译工作，不够优雅而且容易使代码依赖与特定的操作系统；Compiler API通过一套易用的标准的API提供了更加丰富的方式去做动态编译,而且是跨平台的。 5：轻量级Http Server API JDK6 提供了一个简单的Http Server API,据此我们可以构建自己的嵌入式Http Server,它支持Http和Https协议,提供了HTTP1.1的部分实现，没有被实现的那部分可以通过扩展已有的Http Server API来实现,程序员必须自己实现HttpHandler接口,HttpServer会调用HttpHandler实现类的回调方法来处理客户端请求,在 这里,我们把一个Http请求和它的响应称为一个交换,包装成HttpExchange类,HttpServer负责将HttpExchange传给 HttpHandler实现类的回调方法. 6：插入式注解处理API(Pluggable Annotation Processing API) 插入式注解处理API(JSR 269)提供一套标准API来处理Annotations(JSR 175) 实 际上JSR 269不仅仅用来处理Annotation,我觉得更强大的功能是它建立了Java 语言本身的一个模型,它把method, package, constructor, type, variable, enum, annotation等Java语言元素映射为Types和Elements(两者有什么区别?), 从而将Java语言的语义映射成为对象, 我们可以在javax.lang.model包下面可以看到这些类. 所以我们可以利用JSR 269提供的API来构建一个功能丰富的元编程(metaprogramming)环境. JSR 269用Annotation Processor在编译期间而不是运行期间处理Annotation, Annotation Processor相当于编译器的一个插件,所以称为插入式注解处理.如果Annotation Processor处理Annotation时(执行process方法)产生了新的Java代码,编译器会再调用一次Annotation Processor,如果第二次处理还有新代码产生,就会接着调用Annotation Processor,直到没有新代码产生为止.每执行一次process()方法被称为一个”round”,这样整个Annotation processing过程可以看作是一个round的序列. JSR 269主要被设计成为针对Tools或者容器的API. 举个例子,我们想建立一套基于Annotation的单元测试框架(如TestNG),在测试类里面用Annotation来标识测试期间需要执行的测试方法 7：用Console开发控制台程序 JDK6 中提供了java.io.Console 类专用来访问基于字符的控制台设备. 你的程序如果要与Windows下的cmd或者Linux下的Terminal交互,就可以用Console类代劳. 但我们不总是能得到可用的Console, 一个JVM是否有可用的Console依赖于底层平台和JVM如何被调用. 如果JVM是在交互式命令行(比如Windows的cmd)中启动的,并且输入输出没有重定向到另外的地方,那么就可以得到一个可用的Console实例. 8：对脚本语言的支持如: ruby, groovy, javascript 9：Common Annotations Common annotations原本是Java EE 5.0(JSR 244)规范的一部分，现在SUN把它的一部分放到了Java SE 6.0中. 随 着Annotation元数据功能(JSR 175)加入到Java SE 5.0里面，很多Java 技术(比如EJB,Web Services)都会用Annotation部分代替XML文件来配置运行参数（或者说是支持声明式编程,如EJB的声明式事务）, 如果这些技术为通用目的都单独定义了自己的Annotations,显然有点重复建设, 所以,为其他相关的Java技术定义一套公共的Annotation是有价值的，可以避免重复建设的同时，也保证Java SE和Java EE 各种技术的一致性. 下面列举出Common Annotations 1.0里面的10个Annotations Common Annotations Annotation Retention Target Description Generated Source ANNOTATION_TYPE, CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE 用于标注生成的源代码 Resource Runtime TYPE, METHOD, FIELD 用于标注所依赖的资源,容器据此注入外部资源依赖，有基于字段的注入和基于setter方法的注入两种方式 Resources Runtime TYPE 同时标注多个外部依赖，容器会把所有这些外部依赖注入 PostConstruct Runtime METHOD 标注当容器注入所有依赖之后运行的方法，用来进行依赖注入后的初始化工作，只有一个方法可以标注为PostConstruct PreDestroy Runtime METHOD 当对象实例将要被从容器当中删掉之前，要执行的回调方法要标注为PreDestroy RunAs Runtime TYPE 用于标注用什么安全角色来执行被标注类的方法，这个安全角色必须和Container 的Security角色一致的。RolesAllowed Runtime TYPE, METHOD 用于标注允许执行被标注类或方法的安全角色，这个安全角色必须和Container 的Security角色一致的 PermitAll Runtime TYPE, METHOD 允许所有角色执行被标注的类或方法 DenyAll Runtime TYPE, METHOD 不允许任何角色执行被标注的类或方法，表明该类或方法不能在Java EE容器里面运行 DeclareRoles Runtime TYPE 用来定义可以被应用程序检验的安全角色，通常用isUserInRole来检验安全角色注意: 1.RolesAllowed,PermitAll,DenyAll不能同时应用到一个类或方法上 2.标注在方法上的RolesAllowed,PermitAll,DenyAll会覆盖标注在类上的RolesAllowed,PermitAll,DenyAll 3.RunAs,RolesAllowed,PermitAll,DenyAll和DeclareRoles还没有加到Java SE 6.0上来 4.处理以上Annotations的工作是由Java EE容器来做, Java SE 6.0只是包含了上面表格的前五种Annotations的定义类,并没有包含处理这些Annotations的引擎,这个工作可以由Pluggable Annotation Processing API(JSR 269)来做 改动的地方最大的就是java GUI界面的显示了，JDK6.0（也就是JDK1.6）支持最新的windows vista系统的Windows Aero视窗效果，而JDK1.5不支持！！！ 你要在vista环境下编程的话最好装jdk6.0，否则它总是换到windows basic视窗效果. JDK 7 新特性jdk7 release notes 1：switch中可以使用字符串 1234567891011String s &#x3D; &quot;test&quot;;switch (s) &#123; case &quot;test&quot; : System.out.println(&quot;test&quot;); case &quot;test1&quot; : System.out.println(&quot;test1&quot;); break ; default : System.out.println(&quot;break&quot;); break ;&#125;1234567891011 2：”&lt;&gt;”的运用List tempList = new ArrayList&lt;&gt;(); 即泛型实例化类型自动推断。 123456789101112131415161718public class JDK7GenericTest &#123; public static void main(String[] args) &#123; &#x2F;&#x2F; Pre-JDK 7 List&lt;String&gt; lst1 &#x3D; new ArrayList&lt;String&gt;(); &#x2F;&#x2F; JDK 7 supports limited type inference for generic instance creation List&lt;String&gt; lst2 &#x3D; new ArrayList&lt;&gt;(); lst1.add(&quot;Mon&quot;); lst1.add(&quot;Tue&quot;); lst2.add(&quot;Wed&quot;); lst2.add(&quot;Thu&quot;); for (String item : lst1) &#123; System.out.println(item); &#125; for (String item : lst2) &#123; System.out.println(item); &#125; &#125;&#125;123456789101112131415161718 3：自定义自动关闭类以下是jdk7 api中的接口，（不过注释太长，删掉了close()方法的一部分注释） 123456789101112131415&#x2F;** * A resource that must be closed when it is no longer needed. * * @author Josh Bloch * @since 1.7 *&#x2F;public interface AutoCloseable &#123; &#x2F;** * Closes this resource, relinquishing any underlying resources. * This method is invoked automatically on objects managed by the * &#123;@code try&#125;-with-resources statement. * *&#x2F; void close() throws Exception;&#125;123456789101112131415 只要实现该接口，在该类对象销毁时自动调用close方法，你可以在close方法关闭你想关闭的资源，例子如下 12345678910111213141516171819class TryClose implements AutoCloseable &#123; @Override public void close() throw Exception &#123; System.out.println(&quot; Custom close method … close resources &quot;); &#125;&#125;&#x2F;&#x2F;请看jdk自带类BufferedReader如何实现close方法（当然还有很多类似类型的类） public void close() throws IOException &#123; synchronized (lock) &#123; if (in &#x3D;&#x3D; null) return; in.close(); in &#x3D; null; cb &#x3D; null; &#125; &#125;12345678910111213141516171819 该方法在try-with-resources语句中会被自动调用，用于自动释放资源。 123456789byte[] b &#x3D; new byte[1024];try (FileInputStream fis &#x3D; new FileInputStream(&quot;my.txt&quot;)) &#123; int data &#x3D; fis.read(); while (data !&#x3D; -1) &#123; data &#x3D; fis.read(b); &#125; throw new RuntimeException();&#125;123456789 4：新增一些取环境信息的工具方法 123456789File System.getJavaIoTempDir() &#x2F;&#x2F; IO临时文件夹File System.getJavaHomeDir() &#x2F;&#x2F; JRE的安装目录File System.getUserHomeDir() &#x2F;&#x2F; 当前用户目录File System.getUserDir() &#x2F;&#x2F; 启动java进程时所在的目录.......123456789 5：Boolean类型反转，空指针安全，参与位运算(官方features似乎搜不到，也查不到Booleans这个类) 123456789101112131415Boolean Booleans.negate(Boolean booleanObj)True &#x3D;&gt; False , False &#x3D;&gt; True, Null &#x3D;&gt; Nullboolean Booleans.and(boolean[] array)boolean Booleans.or(boolean[] array)boolean Booleans.xor(boolean[] array)boolean Booleans.and(Boolean[] array)boolean Booleans.or(Boolean[] array)boolean Booleans.xor(Boolean[] array)123456789101112131415 6： 两个char间的equals (官方features似乎搜不到) boolean Character.equalsIgnoreCase(char ch1, char ch2) 7：安全的加减乘除 (官方features似乎搜不到) 1234567891011121314151617181920212223int Math.safeToInt(long value)int Math.safeNegate(int value)long Math.safeSubtract(long value1, int value2)long Math.safeSubtract(long value1, long value2)int Math.safeMultiply(int value1, int value2)long Math.safeMultiply(long value1, int value2)long Math.safeMultiply(long value1, long value2)long Math.safeNegate(long value)int Math.safeAdd(int value1, int value2)long Math.safeAdd(long value1, int value2)long Math.safeAdd(long value1, long value2)int Math.safeSubtract(int value1, int value2)1234567891011121314151617181920212223 8：对Java集合（Collections）的增强支持 (官方features似乎搜不到) 在JDK1.7之前的版本中，Java集合容器中存取元素的形式如下： 以List、Set、Map集合容器为例： 1234567891011121314151617&#x2F;&#x2F;创建List接口对象List&lt;String&gt; list&#x3D;new ArrayList&lt;String&gt;();list.add(&quot;item&quot;); &#x2F;&#x2F;用add()方法添加对象String Item&#x3D;list.get(0); &#x2F;&#x2F;用get()方法获取对象&#x2F;&#x2F;创建Set接口对象Set&lt;String&gt; set&#x3D;new HashSet&lt;String&gt;();set.add(&quot;item&quot;); &#x2F;&#x2F;用add()方法添加对象&#x2F;&#x2F;创建Map接口对象Map&lt;String,Integer&gt; map&#x3D;new HashMap&lt;String,Integer&gt;();map.put(&quot;key&quot;,1); &#x2F;&#x2F;用put()方法添加对象int value&#x3D;map.get(&quot;key&quot;);1234567891011121314151617 在JDK1.7中，摒弃了Java集合接口的实现类，如：ArrayList、HashSet和HashMap。而是直接采用[]、{}的形式存入对象，采用[]的形式按照索引、键值来获取集合中的对象，如下 123456List&lt;String&gt; list&#x3D;[&quot;item&quot;]; &#x2F;&#x2F;向List集合中添加元素String item&#x3D;list[0]; &#x2F;&#x2F;从List集合中获取元素Set&lt;String&gt; set&#x3D;&#123;&quot;item&quot;&#125;; &#x2F;&#x2F;向Set集合对象中添加元素Map&lt;String,Integer&gt; map&#x3D;&#123;&quot;key&quot;:1&#125;; &#x2F;&#x2F;向Map集合中添加对象int value&#x3D;map[&quot;key&quot;]; &#x2F;&#x2F;从Map集合中获取对象123456 9：数值可加下划线 例如：int one_million = 1_000_000; 10：支持二进制文字 例如：int binary = 0b1001_1001; 11：简化了可变参数方法的调用 当程序员试图使用一个不可具体化的可变参数并调用一个varargs （可变）方法时，编辑器会生成一个“非安全操作”的警告。 12：在try catch异常扑捉中，一个catch可以写多个异常类型，用”|”隔开** 12345try &#123; ......&#125; catch(ClassNotFoundException|SQLException ex) &#123; ex.printStackTrace();&#125;12345 13：jdk7之前，你必须用try{}finally{}在try内使用资源，在finally中关闭资源，不管try中的代码是否正常退出或者异常退出。jdk7之后，你可以不必要写finally语句来关闭资源，只要你在try()的括号内部定义要使用的资源 123456789101112131415161718import java.io.*;&#x2F;&#x2F; Copy from one file to another file character by character.&#x2F;&#x2F; JDK 7 has a try-with-resources statement, which ensures that&#x2F;&#x2F; each resource opened in try() is closed at the end of the statement.public class FileCopyJDK7 &#123; public static void main(String[] args) &#123; try (BufferedReader in &#x3D; new BufferedReader(new FileReader(&quot;in.txt&quot;)); BufferedWriter out &#x3D; new BufferedWriter(new FileWriter(&quot;out.txt&quot;))) &#123; int charRead; while ((charRead &#x3D; in.read()) !&#x3D; -1) &#123; System.out.printf(&quot;%c &quot;, (char)charRead); out.write(charRead); &#125; &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125;&#125;123456789101112131415161718 JAVA8新特性1：接口的默认方法 Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 default关键字即可，这个特征又叫做扩展方法，示例如下： 123456interface Formula &#123; double calculate(int a); default double sqrt(int a) &#123; return Math.sqrt(a); &#125;&#125;123456 上面接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。 12345678Formula formula &#x3D; new Formula() &#123; @Override public double calculate(int a) &#123; return sqrt(a * 100); &#125;&#125;;formula.calculate(100); &#x2F;&#x2F; 100.0formula.sqrt(16); &#x2F;&#x2F; 4.012345678 文中的接口被实现为一个匿名类的实例，该代码非常容易理解，6行代码实现了计算 sqrt(a * 100)。在下一节中，我们将会看到实现单方法接口的更简单的做法。 2：Lambda 表达式 首先看看在老版本的Java中是如何排列字符串的： 1234567List&lt;String&gt; names &#x3D; Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);Collections.sort(names, new Comparator&lt;String&gt;() &#123; @Override public int compare(String a, String b) &#123; return b.compareTo(a); &#125;&#125;);1234567 只需要给静态方法 Collections.sort 传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。 在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式： 123Collections.sort(names, (String a, String b) -&gt; &#123; return b.compareTo(a);&#125;);123 对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点 1Collections.sort(names, (a, b) -&gt; b.compareTo(a));1 java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还能作出什么更方便的东西来 3：函数式接口 Lambda 表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的 接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。 我们可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加 @FunctionalInterface 注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。 1234567@FunctionalInterfaceinterface Converter&lt;F, T&gt; &#123; T convert(F from);&#125;Converter&lt;String, Integer&gt; converter &#x3D; (from) -&gt; Integer.valueOf(from);Integer converted &#x3D; converter.convert(&quot;123&quot;);System.out.println(converted); &#x2F;&#x2F; 1231234567 需要注意如果@FunctionalInterface如果没有指定，上面的代码也是对的。 4：方法与构造函数引用 123Converter&lt;String, Integer&gt; converter &#x3D; Integer::valueOf;Integer converted &#x3D; converter.convert(&quot;123&quot;);System.out.println(converted); &#x2F;&#x2F; 123123 Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法 123converter &#x3D; something::startsWith;String converted &#x3D; converter.convert(&quot;Java&quot;);System.out.println(converted); &#x2F;&#x2F; &quot;J&quot;123 接下来看看构造函数是如何使用::关键字来引用的，首先我们定义一个包含多个构造函数的简单类： 12345678910class Person &#123; String firstName; String lastName; Person() &#123;&#125; Person(String firstName, String lastName) &#123; this.firstName &#x3D; firstName; this.lastName &#x3D; lastName; &#125;&#125;12345678910 接下来我们指定一个用来创建Person对象的对象工厂接口： 123interface PersonFactory&lt;P extends Person&gt; &#123; P create(String firstName, String lastName);&#125;123 这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂 12PersonFactory&lt;Person&gt; personFactory &#x3D; Person::new;Person person &#x3D; personFactory.create(&quot;Peter&quot;, &quot;Parker&quot;);12 我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。 5：Lambda 作用域 在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。 6：访问局部变量 我们可以直接在lambda表达式中访问外层的局部变量： 1234int num &#x3D; 1;&#x2F;&#x2F;这里的num必须不可被后面的代码修改（即隐性的具有final的语义）Converter&lt;Integer, String&gt; stringConverter &#x3D; (from) -&gt; String.valueOf(from + num);stringConverter.convert(2); &#x2F;&#x2F; 31234 7：访问对象字段与静态变量 和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的 123456789101112131415class Lambda4 &#123; static int outerStaticNum; int outerNum; void testScopes() &#123; Converter&lt;Integer, String&gt; stringConverter1 &#x3D; (from) -&gt; &#123; outerNum &#x3D; 23; return String.valueOf(from); &#125;; Converter&lt;Integer, String&gt; stringConverter2 &#x3D; (from) -&gt; &#123; outerStaticNum &#x3D; 72; return String.valueOf(from); &#125;; &#125;&#125;123456789101112131415 8：访问接口的默认方法Java 8 API提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自Google Guava库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。 Predicate接口 Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）： 123456789Predicate&lt;String&gt; predicate &#x3D; (s) -&gt; s.length() &gt; 0;predicate.test(&quot;foo&quot;); &#x2F;&#x2F; truepredicate.negate().test(&quot;foo&quot;); &#x2F;&#x2F; falsePredicate&lt;Boolean&gt; nonNull &#x3D; Objects::nonNull;Predicate&lt;Boolean&gt; isNull &#x3D; Objects::isNull;Predicate&lt;String&gt; isEmpty &#x3D; String::isEmpty;Predicate&lt;String&gt; isNotEmpty &#x3D; isEmpty.negate();123456789 Function 接口 Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）： 123Function&lt;String, Integer&gt; toInteger &#x3D; Integer::valueOf;Function&lt;String, String&gt; backToString &#x3D; toInteger.andThen(String::valueOf);backToString.apply(&quot;123&quot;); &#x2F;&#x2F; &quot;123&quot;123 Supplier 接口 Supplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数 12Supplier&lt;Person&gt; personSupplier &#x3D; Person::new;personSupplier.get(); &#x2F;&#x2F; new Person12 Consumer 接口 Consumer 接口表示执行在单个参数上的操作。 12Consumer&lt;Person&gt; greeter &#x3D; (p) -&gt; System.out.println(&quot;Hello, &quot; + p.firstName);greeter.accept(new Person(&quot;Luke&quot;, &quot;Skywalker&quot;));12 Comparator 接口 Comparator 是老Java中的经典接口， Java 8在此之上添加了多种默认方法： 123456Comparator&lt;Person&gt; comparator &#x3D; (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);Person p1 &#x3D; new Person(&quot;John&quot;, &quot;Doe&quot;);Person p2 &#x3D; new Person(&quot;Alice&quot;, &quot;Wonderland&quot;);comparator.compare(p1, p2); &#x2F;&#x2F; &gt; 0comparator.reversed().compare(p1, p2); &#x2F;&#x2F; &lt; 0123456 Optional 接口 Optional 不是函数是接口，这是个用来防止NullPointerException异常的辅助类型，这是下一届中将要用到的重要概念，现在先简单的看看这个接口能干什么： Optional 被定义为一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是偶尔却可能返回了null，而在Java 8中，不推荐你返回null而是返回Optional。 123456Optional&lt;String&gt; optional &#x3D; Optional.of(&quot;bam&quot;);optional.isPresent(); &#x2F;&#x2F; trueoptional.get(); &#x2F;&#x2F; &quot;bam&quot;optional.orElse(&quot;fallback&quot;); &#x2F;&#x2F; &quot;bam&quot;optional.ifPresent((s) -&gt; System.out.println(s.charAt(0))); &#x2F;&#x2F; &quot;b&quot;123456 Stream 接口 java.util.Stream 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。 Stream 的创建需要指定一个数据源，比如 java.util.Collection的子类，List或者Set， Map不支持。Stream的操作可以串行执行或者并行执行。 首先看看Stream是怎么用，首先创建实例代码的用到的数据List： 123456789List&lt;String&gt; stringCollection &#x3D; new ArrayList&lt;&gt;();stringCollection.add(&quot;ddd2&quot;);stringCollection.add(&quot;aaa2&quot;);stringCollection.add(&quot;bbb1&quot;);stringCollection.add(&quot;aaa1&quot;);stringCollection.add(&quot;bbb3&quot;);stringCollection.add(&quot;ccc&quot;);stringCollection.add(&quot;bbb2&quot;);stringCollection.add(&quot;ddd1&quot;);123456789 Java 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。下面几节将详细解释常用的Stream操作： Filter 过滤 过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作 （比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行 其他Stream操作。 12345stringCollection .stream() .filter((s) -&gt; s.startsWith(&quot;a&quot;)) .forEach(System.out::println);&#x2F;&#x2F; &quot;aaa2&quot;, &quot;aaa1&quot;12345 Sort 排序 排序是一个中间操作，返回的是排序好后的Stream。如果你不指定一个自定义的Comparator则会使用默认排序。 123456stringCollection .stream() .sorted() .filter((s) -&gt; s.startsWith(&quot;a&quot;)) .forEach(System.out::println);&#x2F;&#x2F; &quot;aaa1&quot;, &quot;aaa2&quot;123456 需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的： 12System.out.println(stringCollection);&#x2F;&#x2F; ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd112 Map 映射中间操作map会将元素根据指定的Function接口来依次将元素转成另外的对象，下面的示例展示了将字符串转换为大写字符串。你也可以通过map来讲对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。 123456stringCollection .stream() .map(String::toUpperCase) .sorted((a, b) -&gt; b.compareTo(a)) .forEach(System.out::println);&#x2F;&#x2F; &quot;DDD2&quot;, &quot;DDD1&quot;, &quot;CCC&quot;, &quot;BBB3&quot;, &quot;BBB2&quot;, &quot;AAA2&quot;, &quot;AAA1&quot;123456 Match 匹配 Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是最终操作，并返回一个boolean类型的值。 12345678910111213141516171819boolean anyStartsWithA &#x3D; stringCollection .stream() .anyMatch((s) -&gt; s.startsWith(&quot;a&quot;));System.out.println(anyStartsWithA); &#x2F;&#x2F; trueboolean allStartsWithA &#x3D; stringCollection .stream() .allMatch((s) -&gt; s.startsWith(&quot;a&quot;));System.out.println(allStartsWithA); &#x2F;&#x2F; falseboolean noneStartsWithZ &#x3D; stringCollection .stream() .noneMatch((s) -&gt; s.startsWith(&quot;z&quot;));System.out.println(noneStartsWithZ); &#x2F;&#x2F; true12345678910111213141516171819 Count 计数计数是一个最终操作，返回Stream中元素的个数，返回值类型是long。 123456long startsWithB &#x3D; stringCollection .stream() .filter((s) -&gt; s.startsWith(&quot;b&quot;)) .count();System.out.println(startsWithB); &#x2F;&#x2F; 3123456 Reduce 规约 这是一个最终操作，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规越后的结果是通过Optional接口表示的： 1234567Optional&lt;String&gt; reduced &#x3D; stringCollection .stream() .sorted() .reduce((s1, s2) -&gt; s1 + &quot;#&quot; + s2);reduced.ifPresent(System.out::println);&#x2F;&#x2F; &quot;aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2&quot;1234567 Streams 并行 前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。 下面的例子展示了是如何通过并行Stream来提升性能： 首先我们创建一个没有重复元素的大表： 123456int max &#x3D; 1000000;List&lt;String&gt; values &#x3D; new ArrayList&lt;&gt;(max);for (int i &#x3D; 0; i &lt; max; i++) &#123; UUID uuid &#x3D; UUID.randomUUID(); values.add(uuid.toString());&#125;123456 然后我们计算一下排序这个Stream要耗时多久，串行排序： 123456789long t0 &#x3D; System.nanoTime();long count &#x3D; values.stream().sorted().count();System.out.println(count);long t1 &#x3D; System.nanoTime();long millis &#x3D; TimeUnit.NANOSECONDS.toMillis(t1 - t0);System.out.println(String.format(&quot;sequential sort took: %d ms&quot;, millis));&#x2F;&#x2F; 串行耗时: 899 ms123456789 并行排序： 12345678910long t0 &#x3D; System.nanoTime();long count &#x3D; values.parallelStream().sorted().count();System.out.println(count);long t1 &#x3D; System.nanoTime();long millis &#x3D; TimeUnit.NANOSECONDS.toMillis(t1 - t0);System.out.println(String.format(&quot;parallel sort took: %d ms&quot;, millis));&#x2F;&#x2F; 并行排序耗时: 472 ms12345678910 上面两个代码几乎是一样的，但是并行版的快了50%之多，唯一需要做的改动就是将stream()改为parallelStream()。 Map 前面提到过，Map类型不支持stream，不过Map提供了一些新的有用的方法来处理一些日常任务。 12345Map&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();for (int i &#x3D; 0; i &lt; 10; i++) &#123; map.putIfAbsent(i, &quot;val&quot; + i);&#125;map.forEach((id, val) -&gt; System.out.println(val));12345 以上代码很容易理解， putIfAbsent 不需要我们做额外的存在性检查，而forEach则接收一个Consumer接口来对map里的每一个键值对进行操作。 下面的例子展示了map上的其他有用的函数： 12345678910map.computeIfPresent(3, (num, val) -&gt; val + num);map.get(3); &#x2F;&#x2F; val33map.computeIfPresent(9, (num, val) -&gt; null);map.containsKey(9); &#x2F;&#x2F; falsemap.computeIfAbsent(23, num -&gt; &quot;val&quot; + num);map.containsKey(23); &#x2F;&#x2F; truemap.computeIfAbsent(3, num -&gt; &quot;bam&quot;);map.get(3); &#x2F;&#x2F; val3312345678910 接下来展示如何在Map里删除一个键值全都匹配的项： 1234map.remove(3, &quot;val3&quot;);map.get(3); &#x2F;&#x2F; val33map.remove(3, &quot;val33&quot;);map.get(3); &#x2F;&#x2F; null1234 另外一个有用的方法： 1map.getOrDefault(42, &quot;not found&quot;); &#x2F;&#x2F; not found1 对Map的元素做合并也变得很容易了： 1234map.merge(9, &quot;val9&quot;, (value, newValue) -&gt; value.concat(newValue));map.get(9); &#x2F;&#x2F; val9map.merge(9, &quot;concat&quot;, (value, newValue) -&gt; value.concat(newValue));map.get(9); &#x2F;&#x2F; val9concat1234 Merge做的事情是如果键名不存在则插入，否则则对原键对应的值做合并操作并重新插入到map中。 9：Date API Java 8 在包java.time下包含了一组全新的时间日期API。新的日期API和开源的Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分：Clock 时钟 Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。 1234Clock clock &#x3D; Clock.systemDefaultZone();long millis &#x3D; clock.millis();Instant instant &#x3D; clock.instant();Date legacyDate &#x3D; Date.from(instant); &#x2F;&#x2F; legacy java.util.Date1234 Timezones 时区 在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。 12345678System.out.println(ZoneId.getAvailableZoneIds());&#x2F;&#x2F; prints all available timezone idsZoneId zone1 &#x3D; ZoneId.of(&quot;Europe&#x2F;Berlin&quot;);ZoneId zone2 &#x3D; ZoneId.of(&quot;Brazil&#x2F;East&quot;);System.out.println(zone1.getRules());System.out.println(zone2.getRules());&#x2F;&#x2F; ZoneRules[currentStandardOffset&#x3D;+01:00]&#x2F;&#x2F; ZoneRules[currentStandardOffset&#x3D;-03:00]12345678 LocalTime 本地时间 LocalTime 定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差： 123456789LocalTime now1 &#x3D; LocalTime.now(zone1);LocalTime now2 &#x3D; LocalTime.now(zone2);System.out.println(now1.isBefore(now2)); &#x2F;&#x2F; falselong hoursBetween &#x3D; ChronoUnit.HOURS.between(now1, now2);long minutesBetween &#x3D; ChronoUnit.MINUTES.between(now1, now2);System.out.println(hoursBetween); &#x2F;&#x2F; -3System.out.println(minutesBetween); &#x2F;&#x2F; -239123456789 LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串。 12345678910LocalTime late &#x3D; LocalTime.of(23, 59, 59);System.out.println(late); &#x2F;&#x2F; 23:59:59DateTimeFormatter germanFormatter &#x3D; DateTimeFormatter .ofLocalizedTime(FormatStyle.SHORT) .withLocale(Locale.GERMAN);LocalTime leetTime &#x3D; LocalTime.parse(&quot;13:37&quot;, germanFormatter);System.out.println(leetTime); &#x2F;&#x2F; 13:37LocalDate 本地日期12345678910 LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。 12345678LocalDate today &#x3D; LocalDate.now();LocalDate tomorrow &#x3D; today.plus(1, ChronoUnit.DAYS);LocalDate yesterday &#x3D; tomorrow.minusDays(2);LocalDate independenceDay &#x3D; LocalDate.of(2014, Month.JULY, 4);DayOfWeek dayOfWeek &#x3D; independenceDay.getDayOfWeek();System.out.println(dayOfWeek); &#x2F;&#x2F; FRIDAY12345678 从字符串解析一个LocalDate类型和解析LocalTime一样简单： 123456DateTimeFormatter germanFormatter &#x3D; DateTimeFormatter .ofLocalizedDate(FormatStyle.MEDIUM) .withLocale(Locale.GERMAN);LocalDate xmas &#x3D; LocalDate.parse(&quot;24.12.2014&quot;, germanFormatter);System.out.println(xmas); &#x2F;&#x2F; 2014-12-24123456 LocalDateTime 本地日期时间 LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。 123456789LocalDateTime sylvester &#x3D; LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);DayOfWeek dayOfWeek &#x3D; sylvester.getDayOfWeek();System.out.println(dayOfWeek); &#x2F;&#x2F; WEDNESDAYMonth month &#x3D; sylvester.getMonth();System.out.println(month); &#x2F;&#x2F; DECEMBERlong minuteOfDay &#x3D; sylvester.getLong(ChronoField.MINUTE_OF_DAY);System.out.println(minuteOfDay); &#x2F;&#x2F; 1439123456789 只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date。 12345Instant instant &#x3D; sylvester .atZone(ZoneId.systemDefault()) .toInstant();Date legacyDate &#x3D; Date.from(instant);System.out.println(legacyDate); &#x2F;&#x2F; Wed Dec 31 23:59:59 CET 201412345 格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式： 123456DateTimeFormatter formatter &#x3D; DateTimeFormatter .ofPattern(&quot;MMM dd, yyyy - HH:mm&quot;);LocalDateTime parsed &#x3D; LocalDateTime.parse(&quot;Nov 03, 2014 - 07:13&quot;, formatter);String string &#x3D; formatter.format(parsed);System.out.println(string); &#x2F;&#x2F; Nov 03, 2014 - 07:13123456 和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。关于时间日期格式的详细信息：http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html 10：Annotation 注解 在Java 8中支持多重注解了，先看个例子来理解一下是什么意思。首先定义一个包装类Hints注解用来放置一组具体的Hint注解： 1234567@interface Hints &#123; Hint[] value();&#125;@Repeatable(Hints.class)@interface Hint &#123; String value();&#125;1234567 Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下@Repeatable即可。 例 1: 使用包装类当容器来存多个注解（老方法） 12@Hints(&#123;@Hint(&quot;hint1&quot;), @Hint(&quot;hint2&quot;)&#125;)class Person &#123;&#125;12 例 2：使用多重注解（新方法） 12@Hint(&quot;hint2&quot;)class Person &#123;&#125;12 第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你用反射来获取这些信息： 123456Hint hint &#x3D; Person.class.getAnnotation(Hint.class);System.out.println(hint); &#x2F;&#x2F; nullHints hints1 &#x3D; Person.class.getAnnotation(Hints.class);System.out.println(hints1.value().length); &#x2F;&#x2F; 2Hint[] hints2 &#x3D; Person.class.getAnnotationsByType(Hint.class);System.out.println(hints2.length); &#x2F;&#x2F; 2123456 即便我们没有在Person类上定义@Hints注解，我们还是可以通过 getAnnotation(Hints.class) 来获取 @Hints注解，更加方便的方法是使用 getAnnotationsByType 可以直接获取到所有的@Hint注解。另外Java 8的注解还增加到两种新的target上了： 12@Target(&#123;ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)@interface MyAnnotation &#123;&#125;12 关于Java 8的新特性就写到这了，肯定还有更多的特性等待发掘。JDK 1.8里还有很多很有用的东西，比如Arrays.parallelSort, StampedLock和CompletableFuture等等。 JDK 9新特性1：modularity System 模块化系统 Modularity提供了类似于OSGI框架的功能，模块之间存在相互的依赖关系，可以导出一个公共的API，并且隐藏实现的细节，Java提供该功能的主要的动机在于，减少内存的开销，在JVM启动的时候，至少会有30～60MB的内存加载，主要原因是JVM需要加载rt.jar，不管其中的类是否被classloader加载，第一步整个jar都会被JVM加载到内存当中去，模块化可以根据模块的需要加载程序运行需要的class。 在引入了模块系统之后，JDK 被重新组织成 94 个模块。Java 应用可以通过新增的 jlink 工具，创建出只包含所依赖的 JDK 模块的自定义运行时镜像。这样可以极大的减少 Java 运行时环境的大小。使得JDK可以在更小的设备中使用。采用模块化系统的应用程序只需要这些应用程序所需的那部分JDK模块，而非是整个JDK框架了。 2：HTTP/2 JDK9之前提供HttpURLConnection API来实现Http访问功能，但是这个类基本很少使用，一般都会选择Apache的Http Client，此次在Java 9的版本中引入了一个新的包：java.net.http，里面提供了对Http访问很好的支持，不仅支持Http1.1而且还支持HTTP2（什么是HTTP2？请参见HTTP2的时代来了…），以及WebSocket，据说性能特别好。 3：JShell 用过Python的童鞋都知道，Python 中的读取-求值-打印循环（ Read-Evaluation-Print Loop ）很方便。它的目的在于以即时结果和反馈的形式。 java9引入了jshell这个交互性工具，让Java也可以像脚本语言一样来运行，可以从控制台启动 jshell ，在 jshell 中直接输入表达式并查看其执行结果。当需要测试一个方法的运行效果，或是快速的对表达式进行求值时，jshell 都非常实用。 除了表达式之外，还可以创建 Java 类和方法。jshell 也有基本的代码完成功能。我们在教人们如何编写 Java 的过程中，不再需要解释 “public static void main（String [] args）” 这句废话。 4：不可变集合工厂方法Java 9增加了List.of()、Set.of()、Map.of()和Map.ofEntries()等工厂方法来创建不可变集合。 12345List strs &#x3D; List.of(&quot;Hello&quot;, &quot;World&quot;);List strs List.of(1, 2, 3);Set strs &#x3D; Set.of(&quot;Hello&quot;, &quot;World&quot;);Set ints &#x3D; Set.of(1, 2, 3);Map maps &#x3D; Map.of(&quot;Hello&quot;, 1, &quot;World&quot;, 2);12345 除了更短和更好阅读之外，这些方法也可以避免您选择特定的集合实现。在创建后，继续添加元素到这些集合会导致 “UnsupportedOperationException” 。 5：私有接口方法 Java 8 为我们提供了接口的默认方法和静态方法，接口也可以包含行为，而不仅仅是方法定义。默认方法和静态方法可以共享接口中的私有方法，因此避免了代码冗余，这也使代码更加清晰。如果私有方法是静态的，那这个方法就属于这个接口的。并且没有静态的私有方法只能被在接口中的实例调用。 123456789101112131415interface InterfaceWithPrivateMethods &#123; private static String staticPrivate() &#123; return &quot;static private&quot;; &#125; private String instancePrivate() &#123; return &quot;instance private&quot;; &#125; default void check() &#123; String result &#x3D; staticPrivate(); InterfaceWithPrivateMethods pvt &#x3D; new InterfaceWithPrivateMethods() &#123; &#x2F;&#x2F; anonymous class 匿名类 &#125;; result &#x3D; pvt.instancePrivate(); &#125;&#125;123456789101112131415 6：HTML5风格的Java帮助文档 Java 8之前的版本生成的Java帮助文档是在HTML 4中。在Java 9中，Javadoc 的输出现在符合兼容 HTML5 标准。现在HTML 4是默认的输出标记语言，但是在之后发布的JDK中，HTML 5将会是默认的输出标记语言。 Java帮助文档还是由三个框架组成的结构构成，这是不会变的，并且以HTML 5输出的Java帮助文档也保持相同的结构。每个 Javadoc 页面都包含有关 JDK 模块类或接口来源的信息。 7：多版本兼容 JAR 当一个新版本的 Java 出现的时候，你的库用户要花费很长时间才会切换到这个新的版本。这就意味着库要去向后兼容你想要支持的最老的 Java 版本 (许多情况下就是 Java 6 或者 7)。这实际上意味着未来的很长一段时间，你都不能在库中运用 Java 9 所提供的新特性。幸运的是，多版本兼容 JAR 功能能让你创建仅在特定版本的 Java 环境中运行库程序时选择使用的 class 版本： multirelease.jar├── META-INF│ └── versions│ └── 9│ └── multirelease│ └── Helper.class├── multirelease├── Helper.class└── Main.class 在上述场景中， multirelease.jar 可以在 Java 9 中使用, 不过 Helper 这个类使用的不是顶层的 multirelease.Helper 这个 class, 而是处在“META-INF/versions/9”下面的这个。这是特别为 Java 9 准备的 class 版本，可以运用 Java 9 所提供的特性和库。同时，在早期的 Java 诸版本中使用这个 JAR 也是能运行的，因为较老版本的 Java 只会看到顶层的这个 Helper 类。 8：统一 JVM 日志 Java 9 中 ，JVM 有了统一的日志记录系统，可以使用新的命令行选项-Xlog 来控制 JVM 上 所有组件的日志记录。该日志记录系统可以设置输出的日志消息的标签、级别、修饰符和输出目标等。 9：垃圾收集机制 Java 9 移除了在 Java 8 中 被废弃的垃圾回收器配置组合，同时把G1设为默认的垃圾回收器实现。替代了之前默认使用的Parallel GC，对于这个改变，evens的评论是酱紫的：这项变更是很重要的，因为相对于Parallel来说，G1会在应用线程上做更多的事情，而Parallel几乎没有在应用线程上做任何事情，它基本上完全依赖GC线程完成所有的内存管理。这意味着切换到G1将会为应用线程带来额外的工作，从而直接影响到应用的性能 10：I/O 流新特性java.io.InputStream 中增加了新的方法来读取和复制 InputStream 中包含的数据。readAllBytes：读取 InputStream 中的所有剩余字节。readNBytes： 从 InputStream 中读取指定数量的字节到数组中。transferTo：读取 InputStream 中的全部字节并写入到指定的 OutputStream 中 。 JDK 10新特性1：局部变量的类型推断2：GC改进和内存管理3：线程本地握手4：备用内存设备上的堆分配5：其他Unicode语言 - 标记扩展6：基于Java的实验性JIT编译器7：开源根证书8：根证书颁发认证（CA）9：将JDK生态整合单个存储库10：删除工具javah","categories":[],"tags":[{"name":"java, 特性","slug":"java-特性","permalink":"http://myzhong3.github.io/tags/java-%E7%89%B9%E6%80%A7/"}]},{"title":"java泛型中的通配符","slug":"java泛型中的通配符","date":"2021-01-09T13:25:33.000Z","updated":"2021-03-06T05:48:09.554Z","comments":true,"path":"2021/01/09/java泛型中的通配符/","link":"","permalink":"http://myzhong3.github.io/2021/01/09/java%E6%B3%9B%E5%9E%8B%E4%B8%AD%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6/","excerpt":"","text":"From java doc: https://docs.oracle.com/javase/tutorial/extra/generics/morefun.html In general, if you have an API that only uses a type parameter T as an argument, its uses should take advantage of lower bounded wildcards (? super T). Conversely, if the API only returns T, you’ll give your clients more flexibility by using upper bounded wildcards (? extends T). 使用规则（编译时的限制） 比如：List&lt;? Super T&gt; List&lt;? extends T&gt; 则：写（前者）和读（后者）时使用的对象必须是T的派生类或者T本身。 这两个通配符写法存在的原因是为了提供使用泛型的Collection的宽容性。比如T是S的派生类，但是Collection&lt;T&gt;并不是Collectio&lt;S&gt;的派生类，所以function(Collection&lt;S&gt;)并不允许传入Collection&lt;T&gt;类型的对象。相对应的，function(Collection&lt;? extends S&gt;)就允许传入Collection&lt;T&gt;类型的对象。 Java Doc中的Shape的例子对于理解 upper bounded wildcards (? extends T)很有帮助： https://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html","categories":[],"tags":[{"name":"java generics 泛型 wildcard 通配符","slug":"java-generics-泛型-wildcard-通配符","permalink":"http://myzhong3.github.io/tags/java-generics-%E6%B3%9B%E5%9E%8B-wildcard-%E9%80%9A%E9%85%8D%E7%AC%A6/"}]},{"title":"ZT-java接口里面可以有成员变量么？","slug":"java接口里面可以有成员变量么？","date":"2021-01-03T09:32:32.000Z","updated":"2021-01-03T09:33:12.184Z","comments":true,"path":"2021/01/03/java接口里面可以有成员变量么？/","link":"","permalink":"http://myzhong3.github.io/2021/01/03/java%E6%8E%A5%E5%8F%A3%E9%87%8C%E9%9D%A2%E5%8F%AF%E4%BB%A5%E6%9C%89%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B9%88%EF%BC%9F/","excerpt":"","text":"转帖 答案是：可以，但必须是public static final的，而且必须是public static final的。 既然JDK1.7开始支持接口中存在default方法和static方法，那么这些方法在实现上，难免需要成员变量提供数据支持。先看一个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//基于JDK1.8//IA.javapublic interface IA &#123; int a = 100; double NUM = 1;//等价于public static final double NUM = 1; String name = &quot;IA&quot;; void say(); default void print() &#123; System.out.println(&quot;IA:print()&quot;); &#125; default void pritA() &#123; System.out.println(&quot;IA: &quot; + name); &#125;&#125;//IB.javapublic interface IB &#123; int b = 200; double NUM = 2; String name = &quot;IB&quot;; void say(); default void print() &#123; System.out.println(&quot;IB:print()&quot;); &#125; default void pritB() &#123; System.out.println(&quot;IB: &quot; + name); &#125;&#125;//AB.javapublic class AB implements IA, IB &#123; public static void main(String[] args) &#123; AB ab = new AB(); //ab.name 报错，不能确定是IA中的name还是IB中的 System.out.println(a);//100 因为a和b本质上是静态成员，在静态方法里面可以直接访问 System.out.println(b);//200 System.out.println(IA.NUM);//1.0 System.out.println(IB.NUM);//2.0 System.out.println(IA.name);//IA System.out.println(IB.name);//IB ab.say();//AB:say() ab.print();//AB:print() ab.pritA();//IA: IA ab.pritB();//IB: IB &#125; //必须实现接口中未实现的方法，并且根据排序规则，实现的是IA中的say() @Override public void say() &#123; System.out.println(&quot;AB:say()&quot;); &#125; //必须重写IA和IB中重复(签名相同)的default方法，否则调用print时不知道调用IA中的实现，还是IB中的。 @Override public void print() &#123; System.out.println(&quot;AB:print()&quot;); &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 据此得出结论： 接口中的成员变量默认且只能是public static final的，加这几个访问修饰符是多余的。 接口中的成员变量在实现类中可以直接访问（不管是静态方法还是非静态方法），如果父接口中有重复出现的成员变量，则只能带上接口名加以区分。 接口中default修饰的方法，为子类提供默认实现。 子类实现多个接口，多个接口中有同样签名的方法时，根据排序规则，以写在前面的接口为准。如果父接口中的default方法有重复，则子类必须重写此方法（不然，多个接口中分别提供了各自的实现，子类会不知道调用哪一个）。","categories":[],"tags":[{"name":"java interface member","slug":"java-interface-member","permalink":"http://myzhong3.github.io/tags/java-interface-member/"}]},{"title":"default method in java interface","slug":"default-method-in-java-interface","date":"2021-01-03T09:25:53.000Z","updated":"2021-01-03T09:26:41.227Z","comments":true,"path":"2021/01/03/default-method-in-java-interface/","link":"","permalink":"http://myzhong3.github.io/2021/01/03/default-method-in-java-interface/","excerpt":"","text":"在Java中可以为接口定义一个默认方法的实现，使用的关键字就是default，有了默认方法，实现类就可以不对接口中的默认方法进行重写。 1234567891011121314151617181920212223//为person接口定义两个默认的实现方法public interface Person &#123; default void print()&#123; System.out.println(&quot;i am person&quot;); &#125; default void eat()&#123; System.out.println(&quot;eat&quot;); &#125;&#125;//张三类去实现Person接口中的print()方法public class Zhangsan implements Person&#123; @Override public void print() &#123; System.out.println(&quot;i am zhangsan&quot;); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; var person = new Zhangsan(); person.print(); person.eat(); &#125;&#125; 运行结果： 12i am zhangsaneat","categories":[],"tags":[{"name":"java default interface","slug":"java-default-interface","permalink":"http://myzhong3.github.io/tags/java-default-interface/"}]},{"title":"ZT-Hexo+Github Page","slug":"ZT-Hexo-Github-Page","date":"2020-12-20T03:54:19.000Z","updated":"2020-12-20T04:20:45.591Z","comments":true,"path":"2020/12/20/ZT-Hexo-Github-Page/","link":"","permalink":"http://myzhong3.github.io/2020/12/20/ZT-Hexo-Github-Page/","excerpt":"","text":"超详细Hexo+Github Page搭建技术博客教程【持续更新】https://segmentfault.com/a/1190000017986794","categories":[],"tags":[{"name":"hexo, GitHub, zt","slug":"hexo-GitHub-zt","permalink":"http://myzhong3.github.io/tags/hexo-GitHub-zt/"}]},{"title":"How to use hexo","slug":"How-to-use-hexo","date":"2020-12-06T06:42:35.000Z","updated":"2020-12-06T07:13:51.201Z","comments":true,"path":"2020/12/06/How-to-use-hexo/","link":"","permalink":"http://myzhong3.github.io/2020/12/06/How-to-use-hexo/","excerpt":"","text":"create post hexo new &#39;title&#39; generate hexo hexo g deploy locally hexo s Clean cache hexo clean generate and deploy remote hexo g -d create draft and publish draft hexo new draft &#39;title&#39; hexo publish &#39;title&#39;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-12-06T03:23:00.830Z","updated":"2020-12-06T03:23:00.830Z","comments":true,"path":"2020/12/06/hello-world/","link":"","permalink":"http://myzhong3.github.io/2020/12/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Java java11","slug":"Java-java11","permalink":"http://myzhong3.github.io/tags/Java-java11/"},{"name":"java, 特性","slug":"java-特性","permalink":"http://myzhong3.github.io/tags/java-%E7%89%B9%E6%80%A7/"},{"name":"java generics 泛型 wildcard 通配符","slug":"java-generics-泛型-wildcard-通配符","permalink":"http://myzhong3.github.io/tags/java-generics-%E6%B3%9B%E5%9E%8B-wildcard-%E9%80%9A%E9%85%8D%E7%AC%A6/"},{"name":"java interface member","slug":"java-interface-member","permalink":"http://myzhong3.github.io/tags/java-interface-member/"},{"name":"java default interface","slug":"java-default-interface","permalink":"http://myzhong3.github.io/tags/java-default-interface/"},{"name":"hexo, GitHub, zt","slug":"hexo-GitHub-zt","permalink":"http://myzhong3.github.io/tags/hexo-GitHub-zt/"}]}